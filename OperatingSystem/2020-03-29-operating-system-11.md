# 운영체제 - 교착상태

- Title : 운영체제 - 교착상태
- Date : 2020-03-29
- Category : 운영체제

# 시스템 모델(System Model)

시스템은 경쟁하는 프로세스들 사이에 분배되어야 할 유한한 자원들로 구성되며 여러 프로세스들은 해당 자원을 점유하기 위해 서로 경쟁 구도에 놓여있다. 프로세스가 자원을 사용하기 위해서는 반드시 사용하기 전에 요청을 해야 하고 사용 후에는 반드시 방출해야한다. 정상적인 작동 모드에서 프로세스는 다음의 순서로만 자원을 사용할 수 있다.

1. 요청(Request) : 자원을 요청한다. 다른 프로세스가 사용 중이라서 자원를 받을 수 없다면 대기한다.
2. 사용(Use) : 프로세스는 자원에 대해 작업 수행한다.
3. 방출(Release) : 자원을 다 사용했으면 자원을 방출한다.

# 교착상태(Deadlocks)

둘 이상의 프로세스들이 자원(CPU, 메모리, 파일, 프린터 등..)을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 말한다. 교착 상태에서 프로세스들은 결코 실행을 끝낼 수 없으며, 시스템 자원이 묶여 있어서 다른 작업을 시작하는 것도 불가능하다.

# 교착상태 필요조건

교착 상태는 아래 4가지 조건이 **모두 만족**되야 발생할 수 있다.

## 1. 상호배제(mutual exclusion)

여러 프로세스 중 하나만 임계 구역에 진입할 수 있을 때 즉, 자원을 동시에 공유하지 못할 때

## 2. 점유하며 대기(hold-and-height)

최소 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 대기 중일 때

## 3. 비선점(no-preemption)

자원들을 선점할 수 없어야 한다. 즉, OS가 작동 중인 프로세스를 임의로 중단시킬 수 없을 때

## 4. 순환대기(circular-wait)

프로세스가 순환적으로 서로를 기다릴 때

# 자원 할당 그래프(Resource Allocation Graph)

자원과 프로세스의 관계를 그래프로 도식화한 **자원 할당 그래프**를 통해 데드락 유무를 파악할 수 있다. 자원 할당 그래프란 시스템 내 모든 활성 프로세스의 집합인 P와 모든 자원의 집합인 R로 정점의 집합 V를 구성한다. 이 그래프에서 P로부터 R로 뻣어나가는 간선은 특정 프로세스가 해당 자원을 요청하고 기다리는 것을 표시하며 자원 R에서 P로 뻣어나가는 간선은 할당 간선으로 해당 자원이 해당 프로세스에 할당되어있음을 나타낸다. 이러한 **자원 할당 그래프에 사이클이 있다면 데드락 위험이 있다는 의미가 된다.** 사이클이 있다고 무조건 데드락이 발생하는 것은 아니지만, 사이클이 없으면 절대로 데드락이 발생하지 않는다. 가능성이라고 얘기하는 이유는 자원이 하나의 인스턴스가 아닌 여러 개의 인스턴스를 가질 수도 있기 때문이다. 만약 자원이 여러 개의 인스턴스를 가질 수 있어서 여러 프로세스에게 자원을 제공한다면 교착 상태가 일어나지 않게 된다.

# 교착상태 처리 방법

## 1. 교착 상태 방지(Deadlock Prevention)

교착상태 4가지 필요조건 중 하나를 만족시키지 않음으로서 교착 상태가 발생하는 것을 방지할 수 있다.

### 상호배타 (Mutual exclusion)

읽기 전용 파일은 여러 프로세스가 공유할 수 있게 하여 상호 배타를 깰 수가 있다. 하지만 대부분의 컴퓨터 자원들은 임계 구역 문제를 해결하기위해 상호 배타를 만족해야만 한다. 상호 배타를 깨는 건 현실적으로 불가능한 일이다.

### 보유 및 대기 (Hold and wait)

프로세스가 실행되기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 거다. 이렇게 하면 프로세스가 다른 자원을 요청하여 할당받을 때까지 대기하는 일이 없고 모든 자원을 가지고 프로세스를 시작하기 때문에 대기하는 일이 발생하지 않는다. 하지만 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에 자원 활용률이 떨어지는 단점이 있고 **기아 문제**가 발생할 수 있다. 식사하는 철학자를 예를 들면 젓가락을 동시에 두개를 집게 하고 하나만 집을 수 있다면 아예 못 집게 하는 방법이다. 또는 프로세스가 자원을 점유하지 않을 때만 자원을 요청할 수 있도록 하는 방법도 있다.

### 비선점 (No Preemption)

자원을 점유하고 있는 프로세스가 다른 자원를 요청했을 때 즉시 리자원를 사용할 수 없다면 점유하고 있던 자원을 방출(release)한다.

### 순환 대기 (Circular wait)

모든 자원 유형들에게 전체적인 순서를 부여하여 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 강제하는 것이다. 이를 통해 모든 자원들은 먼저 할당되는 순서가 정해져 있기 때문에 교착상태가 일어날 수 없다. 즉, 자원의 타입에 따라 프로세스마다 일대일 함수로 순서를 지정해준다. 식사하는 철학자 같은 경우는 아이디를 부여하여 홀수번은 오른쪽 왼쪽, 짝수번은 왼쪽 오른쪽 순서로 집도록 하였다. 역시 자원 활용률을 떨어트린다.

## 2. 교착 상태 회피(Deadlock Avoidance)

여기서는 교착 상태를 자원 요청에 대해 운영체제가 잘못 할당한 것으로 정의한다. 운영체제는 리소스 매니저, 리소스 allocator라고 불리듯이 자원을 프로세스에게 골고루 나눠주는 역할을 한다. 즉, **운영체제의 프로세스 관리 부서가 자원을 잘 못 나눠줘서 교착상태가 발생했다고 보는 것**이다. 은행 파산으로 비유할 수 있다. 

이러한 교착 상태는 어떤 프로세스가 요청을 할 때 미래에 대한 분석을 통해 자원 요청을 늦추는 방법으로 피할 수 있다. 시스템이 unsafe 상태가 되지 않도록 해야 하며 만약 unsafe 상태면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 자원 할당 그래프를 구현해 파악하며 리소스 타입이 여러 개면 Banker's algorithm을 사용한다.

> 안전 상태란 이러한 교착 상태 알고리즘을 설계함에 있어 각 유효 자원의 최대 개수까지 어떤 순서로 요청을 하더라도 교착상태를 야기하지 않고 모두 할당을 잘 해줄 수 있음 을 뜻한다.

### Banker's Alogorithm

교착상태 회피 알고리즘으로 프로세스가 리소스를 요청할때마다 수행되며, 이 자원을 할당하면 미래에 교착상태가 발생할지를 시뮬레이션한다.

## 3. 교착 상태 검출 및 복구

교착 상태가 일어나는 것을 허용하며 자원을 마음껏 나눠준다. 어쩌다가 교착상태가 일어나면 이를 회복하는 방법이다. 검출을 위한 오버헤드가 크다. 복구를 위해 프로세스 일부를 강제 종료하거나 자원을 선점하여 일부 프로세스에게 할당한다. 복구를 위해 주기적으로 현재 상태를 기억해둬야하며 데드락이 일어나지 않은 상태로 다시 돌아가야 한다.

### 복구 1. 프로세스를 종료시키는 방법

- 교착 상태 프로세스를 모두 중지
    - 다시 처음부터 계산해야한다.
- 교착 상태가 제거될 때까지 한 프로세스씩 중지하는 방법
    - 각 프로세스가 중지될 때마다 아직도 교착 상태에 있는 지 매번 살펴봐야 하기 때문에 상당한 오버헤드를 유발한다.

**어떤 프로세스를 종료시킬까?**

- 프로세스의 중요도
- 프로세스가 얼마나 오래 실행됐는가
- 얼마나 많을 자원을 사용했는가
- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가
- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가
- 프로세스가 batch인가 interactive한가?

### 복구 2. 자원 선점 방법

교착 상태가 깨어질 때까지 프로세스로부터 자원을 계속적으로 선점해 다른 프로세스에게 주는 방법이다.

**고려사항**

- 희생자 선택(selection of a victim)
    - 어떤 자원과 어느 프로세스가 선점될 것인가 를 고민
- 롤백(rollback)
    - 만약 특정 프로세스의 자원을 강제로 방출하고 선점시켰다면, 그 프로세스를 어떻게 처리 할 것인가에 대한 고민이다. 보통 가장 안전한 방법은 프로세스를 중지시키고 재시작하는 것 즉, 롤백하는 것이다.
- 기아 상태(starvation)
    - 특정 프로세스의 자원을 강제 방출시켜 선점을 시켜주게 되면 그 프로세스는 계속해서 희생자로 선택될 확률이 높고 이경우 그 프로세스는 영원히 실행이 완료되지 못하는 기아상태에 빠질 수 있다. 프로세스가 한정된 시간에만 희생자로 선정된다는 것을 반드시 보장 해야 한다.

## 4. 교착 상태 무시

실제 잘 안일어나니깐 그냥 무시하고..교착상태를 처리하는 것을 응용 개발자의 몫으로 맡기는 것.

참고

[운영체제 | 교착상태(deadlock)란 무엇인가?](https://frontalnh.github.io/2018/04/05/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/)